#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/startscreen.h"
#include "images/grass.h"
#include "images/graphics.h"
#include "images/winscreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
};

OamEntry shadow[128];

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE | OBJ_ENABLE | GRAPHICS_DIMENSION_TYPE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  u16 drawnStart = 0;
 
  u16 move = 1;
  char buffer[200];
  //setup sprites graphics
  DMA[3].src = graphics_palette;
  DMA[3].dst = SPRITEPAL;
  DMA[3].cnt = GRAPHICS_PALETTE_LENGTH | DMA_ON;

  DMA[3].src = graphics;
  DMA[3].dst = &CHARBLOCKBASE[5];
  DMA[3].cnt = GRAPHICS_LENGTH | DMA_ON;
  
  //makes sprites invisible
  for(int i = 0; i < 128; i++)
	shadow[i].attr0 = ATTR0_HIDE;
  
  //setup coordinates for sprites
  u16 playerDefaultX = 10;
  u16 playerDefaultY = 100;
  u16 charizardDefaultX = 5;
  u16 charizardDefaultY = 5;
  u16 venusaurDefaultX = 100;
  u16 venusaurDefaultY = 100;
  u16 blastoiseDefaultX = 140;
  u16 blastoiseDefaultY = 10;

  //setup attributes for sprites
  OamEntry* player3 = shadow;
  player3->attr0 = playerDefaultY | GRAPHICS_PALETTE_TYPE | PLAYER3_SPRITE_SHAPE;
  player3->attr1 = playerDefaultX | PLAYER3_SPRITE_SIZE;
  player3->attr2 = PLAYER3_ID;

  OamEntry* charizard = shadow+1;
  charizard->attr0 = charizardDefaultY | GRAPHICS_PALETTE_TYPE | CHARIZARD_SPRITE_SHAPE;
  charizard->attr1 = charizardDefaultX | CHARIZARD_SPRITE_SIZE;
  charizard->attr2 = CHARIZARD_ID;

  OamEntry* venusaur = shadow+2;
  venusaur->attr0 = venusaurDefaultY | GRAPHICS_PALETTE_TYPE | VENUSAUR_SPRITE_SHAPE;
  venusaur->attr1 = venusaurDefaultX | VENUSAUR_SPRITE_SIZE;
  venusaur->attr2 = VENUSAUR_ID;

  OamEntry* blastoise = shadow+3;
  blastoise->attr0 = blastoiseDefaultY | GRAPHICS_PALETTE_TYPE | BLASTOISE_SPRITE_SHAPE;
  blastoise->attr1 = blastoiseDefaultX | BLASTOISE_SPRITE_SIZE;
  blastoise->attr2 = BLASTOISE_ID;
  
  int numSprites = 4;
  int moveDistance = 4;
  struct sprite sprites[numSprites];

  //use sprites array to make detecting collisions easier
  sprites[0].width = 16;
  sprites[0].height = 16;

  sprites[1].width = 64;
  sprites[1].height = 64;
  sprites[1].ref = (shadow+1);
  
  sprites[2].width = 64;
  sprites[2].height = 64;
  sprites[2].ref = (shadow+2);

  sprites[3].width = 64;
  sprites[3].height = 64;
  sprites[3].ref = (shadow+3);

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
	
    switch (state) {
      case START:
	//if the start screen is already drawn, we don't need to redraw it
	if (!drawnStart) {
		drawFullScreenImageDMA(startscreen);
		drawCenteredString(HEIGHT*1/3, WIDTH*1/2, 0, 0,"Pokemon", 0x0F00);
		drawCenteredString(HEIGHT*2/3, WIDTH*1/2, 0, 0,"PRESS START TO PLAY", 0x0F00);
		drawnStart = 1;
	}
	//if player presses start, begin the game
	if(!KEY_DOWN(BUTTON_START, previousButtons) && KEY_DOWN(BUTTON_START, currentButtons)) {
		//create the game screen and make sprites visible
		drawFullScreenImageDMA(grass);
		drawnStart = 0;
		player3->attr0 = playerDefaultY | GRAPHICS_PALETTE_TYPE | PLAYER3_SPRITE_SHAPE;
		player3->attr1 = playerDefaultX | PLAYER3_SPRITE_SIZE;
		charizard->attr0 = charizardDefaultY | GRAPHICS_PALETTE_TYPE | CHARIZARD_SPRITE_SHAPE;
		venusaur->attr0 = venusaurDefaultY | GRAPHICS_PALETTE_TYPE | VENUSAUR_SPRITE_SHAPE;
		blastoise->attr0 = blastoiseDefaultY | GRAPHICS_PALETTE_TYPE | BLASTOISE_SPRITE_SHAPE;	
		
		//reset status of all sprites to their default
		for (int i = 0; i < numSprites; i++)
			sprites[i].isCaught = 0;

		sprites[0].xcoor = playerDefaultX;
  		sprites[0].ycoor = playerDefaultY;;
		sprites[1].xcoor = charizardDefaultX;
  		sprites[1].ycoor = charizardDefaultY;
		sprites[1].isCaught = 0;
		sprites[2].xcoor = venusaurDefaultX;
  		sprites[2].ycoor = venusaurDefaultY;
		sprites[2].isCaught = 0;
		sprites[3].xcoor = blastoiseDefaultX;
		sprites[3].ycoor = blastoiseDefaultY;
		sprites[3].isCaught = 0;
		
		//draw sprites and reset timer
		DMA[3].src = shadow;
		DMA[3].dst = OAMMEM;
		DMA[3].cnt = 128*4 | DMA_ON;
		vBlankCounter = 0;
		state = PLAY;
	}
	
        break;
      case PLAY:
	//if user presses select, return to start screen
	if(KEY_DOWN(BUTTON_SELECT, currentButtons)){
		state = START;
		drawnStart = 0;
		//make sprites invisible
		for(int i = 0; i < 128; i++)
			shadow[i].attr0 = ATTR0_HIDE;
		DMA[3].src = shadow;
		DMA[3].dst = OAMMEM;
		DMA[3].cnt = 128*4 | DMA_ON;
		break;
	}
	//if user presses up, check collisions, if no collisions move player up
	if(!KEY_DOWN(BUTTON_UP, previousButtons) && KEY_DOWN(BUTTON_UP, currentButtons)){
		for (int i = 1; i < numSprites; i++) {
			if (!(sprites[i].ref->attr0 == ATTR0_HIDE) && !(((sprites[0].ycoor - moveDistance > sprites[i].ycoor + sprites[i].height) || (sprites[0].xcoor > sprites[i].xcoor + sprites[i].width) || (sprites[0].xcoor + sprites[0].width < sprites[i].xcoor) || (sprites[0].ycoor < sprites[i].ycoor)) && (sprites[0].ycoor - moveDistance > 0))) {
				move = 0;
			}
		}
		if (move) {
			sprites[0].ycoor = sprites[0].ycoor - moveDistance;
			player3->attr0 = player3->attr0 - moveDistance;
			
		} else
			move = 1;
	//if user presses down, check collisions, if no collisions move player down
	} else if (!KEY_DOWN(BUTTON_DOWN, previousButtons) && KEY_DOWN(BUTTON_DOWN, currentButtons)) {
		for (int i = 1; i < numSprites; i++) {
			if (!(sprites[i].ref->attr0 == ATTR0_HIDE) && !(((sprites[0].ycoor + moveDistance + sprites[0].height < sprites[i].ycoor) || (sprites[0].xcoor + sprites[0].width < sprites[i].xcoor) || (sprites[0].xcoor > sprites[i].xcoor  + sprites[i].width) || (sprites[0].ycoor > sprites[i].ycoor)) && (sprites[0].ycoor + moveDistance + sprites[0].height < 160))) {
				move = 0;
			}
		}
		if (move) {
			sprites[0].ycoor = sprites[0].ycoor + moveDistance;
			player3->attr0 = player3->attr0 + moveDistance;
			
		} else 
			move = 1;
	//if user presses right, check collisions, if no collisions move player right
	} else if (!KEY_DOWN(BUTTON_RIGHT, previousButtons) && KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
		for (int i = 1; i < numSprites; i++) {
			if (!(sprites[i].ref->attr0 == ATTR0_HIDE) && !(((sprites[0].xcoor + moveDistance + sprites[0].width < sprites[i].xcoor) || (sprites[0].ycoor + sprites[0].height < sprites[i].ycoor) || (sprites[0].ycoor > sprites[i].ycoor + sprites[i].height) || (sprites[0].xcoor > sprites[i].xcoor)) && (sprites[0].xcoor + moveDistance + sprites[0].width < 240))) {
				move = 0;
			}
		}
		if (move) {
			sprites[0].xcoor = sprites[0].xcoor + moveDistance;
			player3->attr1 = player3->attr1 + moveDistance;
			
		} else 
			move = 1;
	//if user presses left, check collisions, if no collisions move player left
	} else if (!KEY_DOWN(BUTTON_LEFT, previousButtons) && KEY_DOWN(BUTTON_LEFT, currentButtons)) {
		for (int i = 1; i < numSprites; i++) {
			if (!(sprites[i].ref->attr0 == ATTR0_HIDE) && !(((sprites[0].xcoor - moveDistance > sprites[i].xcoor + sprites[i].width) || (sprites[0].ycoor > sprites[i].ycoor + sprites[i].height) || (sprites[0].ycoor + sprites[0].height < sprites[i].ycoor) || (sprites[0].xcoor < sprites[i].xcoor)) && (sprites[0].xcoor - moveDistance > 0))){
				move = 0;
			}
		}
		if (move) {
			sprites[0].xcoor = sprites[0].xcoor - moveDistance;
			player3->attr1 = player3->attr1 - moveDistance;
			
		} else
			move = 1;
	}
	
	//if user presses A and is next to a pokemon, the pokemon will disappear
	if (!KEY_DOWN(BUTTON_A, previousButtons) && KEY_DOWN(BUTTON_A, currentButtons)) {
		for (int i = 1; i < numSprites; i++) {
			if (!sprites[i].isCaught && (!(((sprites[0].ycoor - moveDistance > sprites[i].ycoor + sprites[i].height) || (sprites[0].xcoor > sprites[i].xcoor + sprites[i].width) || (sprites[0].xcoor + sprites[0].width < sprites[i].xcoor) || (sprites[0].ycoor < sprites[i].ycoor)))
				|| !(((sprites[0].ycoor + moveDistance + sprites[0].height < sprites[i].ycoor) || (sprites[0].xcoor + sprites[0].width < sprites[i].xcoor) || (sprites[0].xcoor > sprites[i].xcoor  + sprites[i].width) || (sprites[0].ycoor > sprites[i].ycoor)))
				|| !(((sprites[0].xcoor + moveDistance + sprites[0].width < sprites[i].xcoor) || (sprites[0].ycoor + sprites[0].height < sprites[i].ycoor) || (sprites[0].ycoor > sprites[i].ycoor + sprites[i].height) || (sprites[0].xcoor > sprites[i].xcoor)))
				|| !(((sprites[0].xcoor - moveDistance > sprites[i].xcoor + sprites[i].width) || (sprites[0].ycoor > sprites[i].ycoor + sprites[i].height) || (sprites[0].ycoor + sprites[0].height < sprites[i].ycoor) || (sprites[0].xcoor < sprites[i].xcoor))))) {
				
				sprites[i].ref->attr0 = ATTR0_HIDE;
				sprites[i].isCaught = 1;
				sprites[0].isCaught++;
				break;
			}
		}
	}

	//update the timer about every second
	if (vBlankCounter % 60 != 0) {
		drawFullScreenImageDMA(grass);
		int num = vBlankCounter/60;
		snprintf(buffer, 100, "%d", num);
		drawCenteredString(140, 200, 0, 0, "Timer: ", 0);
		drawCenteredString(140, 220, 0, 0, buffer, 0);
		//if player caught all pokemon, display controls to reach win screen
		if (sprites[0].isCaught == numSprites - 1) 
			drawCenteredString(140, 120, 0, 0, "Press Start", 0);

	}
	//redraw sprites in case they have disappeared
	DMA[3].src = shadow;
	DMA[3].dst = OAMMEM;
	DMA[3].cnt = 128*4 | DMA_ON;

	//if all pokemon are caught and the user presses start, display win screen
	if (sprites[0].isCaught == numSprites-1 && KEY_DOWN(BUTTON_START, currentButtons)){
		//erase player from screen
		player3->attr0 = ATTR0_HIDE;
		state = WIN;
		//redraw sprites
		DMA[3].src = shadow;
		DMA[3].dst = OAMMEM;
		DMA[3].cnt = 128*4 | DMA_ON;
		//draw winscreen
		drawFullScreenImageDMA(winscreen);
		int num = vBlankCounter/60;
		snprintf(buffer, 100, "%d", num);
		drawCenteredString(HEIGHT*2/3, WIDTH*1/2, 0, 0, buffer , 0x0F00);
	}
        break;
      case WIN:
	//display win message and time taken to beat the game
	drawCenteredString(HEIGHT*1/3, WIDTH*1/2, 0, -20, "YOU BEAT THE GAME", 0x0F00);
	drawCenteredString(HEIGHT*2/3, WIDTH*1/2, 0, -20, "Time Taken:", 0x0F00);
	if(KEY_DOWN(BUTTON_SELECT, currentButtons)){
		state = START;
		break;
	}
        // state = ?
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}
